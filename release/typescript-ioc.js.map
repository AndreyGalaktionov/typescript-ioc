{"version":3,"sources":["typescript-ioc.ts"],"names":[],"mappings":"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","file":"typescript-ioc.js","sourcesContent":["/// <reference path=\"../node_modules/reflect-metadata/reflect-metadata.d.ts\" />\n\n/*********************** Decorators **************************/\n\n/**\n * Decorator processor for @Singleton annotation\n */\nexport function Singleton(target: Function) {\n    Container.bind(target).scope(Scope.Singleton);\n}\n\n/**\n * Decorator processor for @Scoped annotation\n */\nexport function Scoped(scope: Scope) {\n    return function(target: Function) {\n        Container.bind(target).scope(scope);\n    }\n}\n\n/**\n * Decorator processor for @Scoped annotation\n */\nexport function Provided(provider: Provider) {\n    return function(target: Function) {\n        Container.bind(target).provider(provider);\n    }\n}\n\n/**\n * Decorator processor for @Provides annotation\n */\nexport function Provides(target: Function) {\n    return function(to: Function) {\n        Container.bind(target).to(to);\n    }\n}\n\n/**\n * Decorator processor for @AutoWired annotation\n */\nexport function AutoWired(target: Function) {\n    let existingInjectedParameters: number[] =\n        Reflect.getOwnMetadata(\"params_inject\", target) || [];\n    let newConstructor;\n    if (existingInjectedParameters.length > 0) {\n        const paramTypes: Array<any> =\n            Reflect.getMetadata(\"design:paramtypes\", target);\n        newConstructor = InjectorHanlder.decorateConstructor(function(...args: any[]) {\n            let newArgs: Array<any> = args ? args.concat() : new Array<any>();\n            for (let index of existingInjectedParameters) {\n                if (index >= newArgs.length) {\n                    newArgs.push(Container.get(paramTypes[index]));\n                }\n            }\n            target.apply(this, newArgs);\n            Container.applyInjections(this, target);\n        }, target);\n    }\n    else {\n        newConstructor = InjectorHanlder.decorateConstructor(function(...args: any[]) {\n            target.apply(this, args);\n            Container.applyInjections(this, target);\n        }, target);\n    }\n    let config: ConfigImpl = <ConfigImpl>Container.bind(target)\n    config.toConstructor(newConstructor);\n    return newConstructor;\n}\n\n/**\n * Decorator processor for @Inject annotation\n */\nexport function Inject(...args: any[]) {\n    if (args.length == 2) {\n        return InjectPropertyDecorator.apply(this, args);\n    }\n    else if (args.length == 3 && typeof args[2] === \"number\") {\n        return InjectParamDecorator.apply(this, args);\n    }\n\n    throw new Error(\"Invalid @Inject Decorator declaration.\");\n}\n\nfunction InjectPropertyDecorator(target: Object, key: string) {\n    let t = Reflect.getMetadata(\"design:type\", target, key);\n    Container.addPropertyInjector(target.constructor, key, t);\n}\n\nfunction InjectParamDecorator(target: Object, propertyKey: string | symbol,\n    parameterIndex: number) {\n    if (!propertyKey) // only intercept constructor parameters\n    {\n        let existingInjectedParameters: number[] =\n            Reflect.getOwnMetadata(\"params_inject\", target, propertyKey) || [];\n        existingInjectedParameters.push(parameterIndex);\n        Reflect.defineMetadata(\"params_inject\", existingInjectedParameters,\n            target, propertyKey);\n    }\n}\n\n/*********************** Container **************************/\nclass Map<V> {\n    put(key: any, value: V) {\n        this[key] = value;\n    }\n\n    get(key: any): V {\n        return this[key];\n    }\n}\n\n/**\n * The IoC Container class.\n */\nexport class Container {\n    private static bindings: Map<ConfigImpl> = new Map<ConfigImpl>();\n\n    static bind(source: Function): Config {\n        checkType(source);\n        const baseSource = InjectorHanlder.getConstructorFromType(source);\n        let config: ConfigImpl = Container.bindings.get(baseSource);\n        if (!config) {\n            config = new ConfigImpl(baseSource);\n            Container.bindings.put(baseSource, config);\n        }\n        return config;\n    }\n\n    static get(source: Function) {\n        let config: ConfigImpl = <ConfigImpl>Container.bind(source);\n        if (!config.iocprovider) {\n            config.to(<FunctionConstructor>config.source);\n        }\n        return config.getInstance();\n    }\n\n    static applyInjections(toInject: Object, targetType?: Function) {\n        if (targetType) {\n            const injections: Array<any> = InjectorHanlder.getInjectorFromType(targetType, false);\n            injections.forEach(entry => {\n                entry(toInject);\n            });\n        }\n        else {\n            const injections: Array<any> = InjectorHanlder.getInjectorFromInstance(toInject);\n            injections.forEach(entry => {\n                entry(toInject);\n            });\n        }\n    }\n\n    static addPropertyInjector(target: Function, key: string, propertyType: Function) {\n        const injections: Array<any> = InjectorHanlder.getInjectorFromType(target, false);\n        injections.push(toInject => {\n            Container.injectProperty(toInject, key, propertyType);\n        });\n    }\n\n    static injectProperty(toInject: Object, key: string, source: Function) {\n        toInject[key] = Container.get(source);\n    }\n}\n\nfunction checkType(source: Object) {\n    if (!source) {\n        throw new TypeError('Invalid type requested to IoC ' +\n            'container. Type is not defined.');\n    }\n}\n\nexport interface Config {\n    to(target: Object): Config;\n    provider(provider: Provider): Config;\n    scope(scope: Scope): Config;\n}\n\nclass ConfigImpl implements Config {\n    source: Function;\n    iocprovider: Provider;\n    iocscope: Scope;\n    decoratedConstructor: FunctionConstructor;\n\n    constructor(source: Function) {\n        this.source = source;\n    }\n\n    to(target: FunctionConstructor) {\n        checkType(target);\n        if (this.source === target) {\n            const _this = this;\n            this.iocprovider = {\n                get: () => {\n                    if (_this.decoratedConstructor) {\n                        return new _this.decoratedConstructor();\n                    }\n                    return new target();\n                }\n            };\n        }\n        else {\n            this.iocprovider = {\n                get: () => {\n                    return Container.get(target);\n                }\n            };\n        }\n        return this;\n    }\n\n    toTypeNamed(target: string) {\n        this.iocprovider = {\n            get: () => {\n                checkType(window[target]);\n                let c = Object.create(window[target].prototype);\n                let targetType = c.constructor;\n                checkType(targetType);\n                return new targetType();\n            }\n        };\n\n        return this;\n    }\n\n    provider(provider: Provider) {\n        this.iocprovider = provider;\n        return this;\n    }\n\n    scope(scope: Scope) {\n        this.iocscope = scope;\n        return this;\n    }\n\n    toConstructor(newConstructor: FunctionConstructor) {\n        this.decoratedConstructor = newConstructor;\n        return this;\n    }\n\n    getInstance() {\n        if (!this.iocscope) {\n            this.scope(Scope.Local);\n        }\n        return this.iocscope.resolve(this.iocprovider, this.source);\n    }\n}\n\nexport interface Provider {\n    get(): Object;\n}\n\nexport abstract class Scope {\n    static Local: Scope;\n    static Singleton: Scope;\n\n    abstract resolve(provider: Provider, source: Function): any;\n}\n\nexport class LocalScope extends Scope {\n    resolve(provider: Provider, source: Function) {\n        return provider.get();\n    }\n}\n\nScope.Local = new LocalScope();\n\nexport class SingletonScope extends Scope {\n    private static instances: Map<any> = new Map<any>();\n\n    resolve(provider: Provider, source: Function) {\n        let instance: any = SingletonScope.instances.get(source);\n        if (!instance) {\n            instance = provider.get();\n            SingletonScope.instances.put(source, instance);\n        }\n        return instance;\n    }\n}\n\nScope.Singleton = new SingletonScope();\n\n\n/**\n * Utility class to handle injection behavior on class decorations.\n */\nclass InjectorHanlder {\n    static typeInjections: Map<Array<any>> = new Map<Array<any>>();\n\n    static decorateConstructor(derived: Function, base: Function) {\n        for (var p in base) {\n            if (base.hasOwnProperty(p) && !derived.hasOwnProperty(p)) {\n                derived[p] = base[p];\n            }\n        }\n        derived['__parent'] = base;\n        function __() { this.constructor = derived; }\n        derived.prototype = base === null ? Object.create(base) :\n            (__.prototype = base.prototype, new __());\n        return derived;\n    }\n\n    static getConstructorFromType(target: Function): FunctionConstructor {\n        let typeConstructor: Function = target;\n        if (typeConstructor['name']) {\n            return <FunctionConstructor>typeConstructor;\n        }\n        while (typeConstructor = typeConstructor['__parent']) {\n            if (typeConstructor['name']) {\n                return <FunctionConstructor>typeConstructor;\n            }\n        }\n        throw TypeError('Can not identify the base Type for requested target');\n    }\n\n    static getConstructorFromInstance(target: Object): FunctionConstructor {\n        return InjectorHanlder.getConstructorFromType(target.constructor);\n    }\n    static getInjectorFromType(target: Function, recursive: boolean) {\n        const baseConstructor: Object = InjectorHanlder.getConstructorFromType(target);\n        if (!InjectorHanlder.typeInjections[<any>baseConstructor]) {\n            InjectorHanlder.typeInjections[<any>baseConstructor] = new Array<any>();\n        }\n        let result: Array<any> = InjectorHanlder.typeInjections[<any>baseConstructor];\n        if (recursive) {\n            let parent: Function = baseConstructor['__parent'];\n            if (parent) {\n                result = InjectorHanlder.getInjectorFromType(parent, true).concat(result);\n            }\n        }\n        return result;\n    }\n\n    static getInjectorFromInstance(target: Object) {\n        const baseConstructor: Function = InjectorHanlder.getConstructorFromInstance(target);\n        return InjectorHanlder.getInjectorFromType(baseConstructor, true)\n    }\n}\n\n"]}